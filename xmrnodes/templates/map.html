{% extends 'base.html' %}



{% block warning %}
{% endblock %}

{% block content %}
<link rel="preload stylesheet" href="/static/css/vendor/ol.css" type="text/css">
<script src="/static/js/vendor/ol.js"></script>
<script src="/static/js/vendor/jquery.min.js"></script>
<div class="box">
  <p>Total Peers: {{ recent_peers }}</p>
  <p>Source Node: <strong>{{ source_node }}</strong></p>
  <p>
    This is not a full representation of the entire Monero network,
    just a look into the peers being recursively crawled from the source node.
    New peers are searched every hour and unresponsive nodes are removed.
  </p>
  <p>
    The map is currently showing {{ shown_peers }} peers seen in the past 72 hours.
  </p>
  <p><span id="selectedNode">Click a node below to see connection details.</span></p>
</div>
<div id="loadingContainer">
    <h1>Loading map... <span id="loadProgress"></span></h1>
    <img id="loading" src="/static/images/helping.gif" style="width: 30%;" />
  </div>
  <div id="map" class="map"></div>
  <div id="popup" class="popup" title="Welcome to OpenLayers"></div>
<script>
  async function fetchWithDelay(total, delayMs) {
    for(let i=0; i < total + 1; i++) {
      document.getElementById('loadProgress').innerHTML = `%${Math.round(i / total * 100, 2)}`;
      try {
        await fetch(`?fetch=1&offset=${i}`)
          .then((res) => res.json())
          .then((d) => {
            for (var url in d.peers) {
              let peer = d.peers[url];
              var feature = new ol.Feature(
                new ol.geom.Point(ol.proj.transform([peer.lon, peer.lat], 'EPSG:4326', 'EPSG:3857'))
              );
              feature.description = [
                `Node ${url}`,
                `Last Seen ${peer.last_seen}`
              ];
              feature.setStyle(new ol.style.Style({
                image: new ol.style.Circle({
                  radius: 5,
                  fill: new ol.style.Fill({
                    color: peer.rgba,
                  }),
                  stroke: new ol.style.Stroke({
                    color: '#000',
                    width: 1
                  })
                })
              }));
              markerLayer.getSource().addFeature(feature);
            }
          })
      } catch (err) {
        console.error(`Error on request ${i}`);
      }
    }
    // Remove loader and show map
    document.getElementById('loadingContainer').remove();
    document.getElementById('map').style['opacity'] = 1;
  }

  async function loadMap() {

    // Marker layer
    markerLayer = new ol.layer.Vector({
      source: new ol.source.Vector({
        features: [],
        projection: 'EPSG:3857'
      })
    });

    // Create the map
    var map = new ol.Map({
      target: 'map',
      layers: [
        new ol.layer.Tile({
          source: new ol.source.OSM(),
          preload: 2
        }),
        markerLayer
      ],
      view: new ol.View({
        center: ol.proj.fromLonLat([0, 25]),
        minZoom: 3,
        zoom: 3,
        maxZoom: 10
      })
    });

    // Fetch paginated nodes
    const res = await fetch('?fetch=1')
      .then((res) => res.json());

    fetchWithDelay(res.total, 300);

    // Setup popup
    var popup = new ol.Overlay({
      element: $('#popup')[0],
    });
    map.addOverlay(popup);

    // Show details on each pixel
    map.on("click", function(e) {
      var element = popup.getElement();
      map.forEachFeatureAtPixel(e.pixel, function (feature, layer) {
        var coordinate = e.coordinate;
        let sel = $('#selectedNode');
        sel.html(`${feature.description[0]} ${feature.description[1]}`);
      });
    });
  }

  // Wait for full load
  addEventListener("DOMContentLoaded", (event) => {
    document.getElementById('map').style['opacity'] = 0;
    setTimeout(function() {
      loadMap();
    }, 500);
  });
</script>

{% endblock %}